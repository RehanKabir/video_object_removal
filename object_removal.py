# -*- coding: utf-8 -*-
"""homography_transformation_from_first_reference_image.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-JMCmCOBFwBP9NTjQH4TRYqljJ5EsQYV
"""

!pip install util

import csv
from datetime import datetime
import os

import cv2
import numpy as np

# Import util.py from the local directory
import util

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

#output_folder = "/content/drive/MyDrive/Video Editing Research Project/generation_from_first_frame/homography_info"

THRESHOLD = 0.6
NUM_ITERS = 1000

def computeHomography(pairs):
    """Solves for the homography given any number of pairs of points. Visit
    http://6.869.csail.mit.edu/fa12/lectures/lecture13ransac/lecture13ransac.pdf
    slide 9 for more details.

    Args:
        pairs (List[List[List]]): List of pairs of (x, y) points.

    Returns:
        np.ndarray: The computed homography.
    """
    A = []
    for x1, y1, x2, y2 in pairs:
        A.append([x1, y1, 1, 0, 0, 0, -x2 * x1, -x2 * y1, -x2])
        A.append([0, 0, 0, x1, y1, 1, -y2 * x1, -y2 * y1, -y2])
    A = np.array(A)

    # Singular Value Decomposition (SVD)
    U, S, V = np.linalg.svd(A)

    # V has shape (9, 9) for any number of input pairs. V[-1] is the eigenvector
    # of (A^T)A with the smallest eigenvalue. Reshape into 3x3 matrix.
    H = np.reshape(V[-1], (3, 3))

    # Normalization
    H = (1 / H.item(8)) * H
    return H

def dist(pair, H):
    """Returns the geometric distance between a pair of points given the
    homography H.

    Args:
        pair (List[List]): List of two (x, y) points.
        H (np.ndarray): The homography.

    Returns:
        float: The geometric distance.
    """
    # points in homogeneous coordinates
    p1 = np.array([pair[0], pair[1], 1])
    p2 = np.array([pair[2], pair[3], 1])

    p2_estimate = np.dot(H, np.transpose(p1))
    p2_estimate = (1 / p2_estimate[2]) * p2_estimate

    return np.linalg.norm(np.transpose(p2) - p2_estimate)

def RANSAC(point_map, threshold=THRESHOLD, verbose=True):
    """Runs the RANSAC algorithm.

    Args:
        point_map (List[List[List]]): Map of (x, y) points from one image to the
            another image.
        threshold (float, optional): The minimum portion of points that should
            be inliers before the algorithm terminates. Defaults to THRESHOLD.
        verbose (bool, optional): True if additional information should be
            printed. Defaults to True.

    Returns:
        (np.ndarray, set(List[List])): The homography and set of inliers.
    """
    if verbose:
        print(f'Running RANSAC with {len(point_map)} points...')
    bestInliers = set()
    homography = None
    for i in range(NUM_ITERS):
        # randomly choose 4 points from the matrix to compute the homography
        pairs = [point_map[i] for i in np.random.choice(len(point_map), 4)]

        H = computeHomography(pairs)
        inliers = {(c[0], c[1], c[2], c[3])
                   for c in point_map if dist(c, H) < 500}

        if verbose:
            print(f'\x1b[2K\r└──> iteration {i + 1}/{NUM_ITERS} ' +
                  f'\t{len(inliers)} inlier' + ('s ' if len(inliers) != 1 else ' ') +
                  f'\tbest: {len(bestInliers)}', end='')

        if len(inliers) > len(bestInliers):
            bestInliers = inliers
            homography = H
            if len(bestInliers) > (len(point_map) * threshold):
                break

    if verbose:
        print(f'\nNum matches: {len(point_map)}')
        print(f'Num inliers: {len(bestInliers)}')
        print(f'Min inliers: {len(point_map) * threshold}')

    return homography, bestInliers

def createPointMap(image1, image2, directory, verbose=True):
    """Creates a point map of shape (n, 4) where n is the number of matches
    between the two images. Each row contains (x1, y1, x2, y2), where (x1, y1)
    in image1 maps to (x2, y2) in image2.

    sift.detectAndCompute returns
        keypoints: a list of keypoints
        descriptors: a numpy array of shape (num keypoints, 128)

    Args:
        image1 (cv2.Mat): The first image.
        image2 (cv2.Mat): The second image.
        directory (str): The directory to save a .csv file to.
        verbose (bool, optional): True if additional information should be
            printed. Defaults to True.

    Returns:
        List[List[List]]: The point map of (x, y) points from image1 to image2.
    """
    if verbose:
        print('Finding keypoints and descriptors for both images...')
    sift = cv2.SIFT_create()
    kp1, desc1 = sift.detectAndCompute(image1, None)
    kp2, desc2 = sift.detectAndCompute(image2, None)

    cv2.imwrite(util.OUTPUT_PATH + 'keypoints-leftwall.jpg',
                cv2.drawKeypoints(image1, kp1, image1))
    cv2.imwrite(util.OUTPUT_PATH + 'keypoints-rightwall.jpg',
                cv2.drawKeypoints(image2, kp2, image2))

    if verbose:
        print('Determining matches...')
    matches = cv2.BFMatcher(cv2.NORM_L2, True).match(desc1, desc2)

    point_map = np.array([
        [kp1[match.queryIdx].pt[0],
         kp1[match.queryIdx].pt[1],
         kp2[match.trainIdx].pt[0],
         kp2[match.trainIdx].pt[1]] for match in matches
    ])

    cv2.imwrite(util.OUTPUT_PATH + 'matches.png',
                util.drawMatches(image1, image2, point_map))

    with open(f'{util.POINT_MAPS_PATH}/{directory}-point_map.csv', 'w') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['x1', 'y1', 'x2', 'y2'])
        for line in point_map:
            writer.writerow(line)

    return point_map

def main(image1, image2, directory, verbose=True):
    """Analyzes the relation between image1 and image2 by computing a point map
    and running the RANSAC algorithm to compute the homography between the two
    images.

    Args:
        image1_path (str): The path to the first image.
        image2_path (str): The path to the second image.
        directory (str): The directory to to read from a saved .csv file or
            write to a new one.
        verbose (bool, optional): True if additional information should be
            printed. Defaults to True.

    Returns:
        (List[List[List]], set(List[List]), np.ndarray): The computed point map,
            the set of inlier points, and the computed homography
    """
    # # Read images in black and white
    # # image1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
    # # image2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)

    # # Read images normally
    # image1 = cv2.imread(image1_path)
    # image2 = cv2.imread(image2_path)

    # # Analyze relation between images
    # point_map = createPointMap(image1, image2, directory, verbose=verbose)
    # homography, inliers = RANSAC(point_map, verbose=verbose)

    # cv2.imwrite(output_folder + '/inlier_matches.png',
    #             drawMatches(image1, image2, point_map, inliers))

    # with open(output_folder + '/info.txt', 'w') as f:
    #     f.write(f'Homography:\n{str(homography)}\n\n')
    #     f.write(f'Num inliers: {len(inliers)}')

    # return point_map, inliers, homography

    point_map = None
    if verbose:
        print('Creating point map...')
    point_map = createPointMap(image1, image2, directory, verbose=verbose)

    homography, inliers = RANSAC(point_map, verbose=verbose)

    cv2.imwrite(util.OUTPUT_PATH + 'inlier_matches.png',
                util.drawMatches(image1, image2, point_map, inliers))

    with open(util.OUTPUT_PATH + 'info.txt', 'w') as f:
        f.write(f'Homography:\n{str(homography)}\n\n')
        f.write(f'Num inliers: {len(inliers)}')

    return point_map, inliers, homography

# Function to create a video from a list of frames
def frames_to_video(frames_folder, output_path, fps=30):
    frame_files = sorted(os.listdir(frames_folder))  # Assuming frames are named in sequential order
    frame = cv2.imread(os.path.join(frames_folder, frame_files[0]))
    height, width, _ = frame.shape

    # Define the codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Change codec as per requirement
    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

    for frame_file in frame_files:
        frame_path = os.path.join(frames_folder, frame_file)
        frame = cv2.imread(frame_path)
        out.write(frame)

    # Release resources
    out.release()



if __name__ == '__main__':

    # Set directory name
    directory = "homography_info"

    # Define verbosity
    verbose = True

    # Update util paths
    util.OUTPUT_PATH += f'/content/drive/MyDrive/Video Editing Research Project/generation_from_first_image/{directory}/'
    util.POINT_MAPS_PATH += f'/content/drive/MyDrive/Video Editing Research Project/generation_from_first_image/'


    # Path to the folder containing images in Google Drive
    folder_path = "/content/drive/MyDrive/Video Editing Research Project/reference_frames/"

    # Initialize an empty list to store frames
    frame_paths = []

    # Iterate through each file in the folder
    for filename in os.listdir(folder_path):
        # Check if the file is an image
        if filename.endswith(('.jpg')):
            # Construct the full path to the image file
            file_path = os.path.join(folder_path, filename)
            # Append the image to the frames list
            frame_paths.append(file_path)


    #Folder where all the transformed frames will go
    warped_image_folder = "/content/drive/MyDrive/Video Editing Research Project/generation_from_first_frame/"
    user_video_generated_frame = cv2.imread("/content/drive/MyDrive/Video Editing Research Project/user_frames/frame_0000.jpg", 0)
    user_video_warped_frames_list = []

    num_frames = len(frame_paths)
    for path_index in range(num_frames):
        if path_index != num_frames - 1:
          # Define paths
          image1 = cv2.imread(frame_paths[path_index], 0)
          image2 = cv2.imread(frame_paths[path_index + 1], 0)

          # Create output directory
          os.makedirs(util.OUTPUT_PATH, exist_ok=True)
          os.makedirs(util.POINT_MAPS_PATH, exist_ok=True)

          # Obtain the results from the main function
          point_map, inliers, homography = main(image1, image2, directory, verbose)
          print("NUMBER " + str(path_index) + " IMAGE\n")

          # Apply the homography to your image
          height, width = user_video_generated_frame.shape[:2]
          user_video_generated_frame = cv2.warpPerspective(user_video_generated_frame, homography, (width, height))
          user_video_warped_frames_list.append(user_video_generated_frame)

          # Save the warped image to the Google Drive folder
          output_image_path = os.path.join(warped_image_folder, f"frame_{path_index:04d}.jpg")
          cv2.imwrite(output_image_path, user_video_generated_frame)

    frames_to_video(warped_image_folder, warped_image_folder + "1_video_generated_from_first_frame.mp4")

